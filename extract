#!/usr/bin/env bash
# GNU bash, version 4.2.45(2)-release (x86_64-unknown-linux-gnu)
#
# © Copyright 2014 Ryan Delaney. All rights reserved.  This work is
# distributed WITHOUT ANY WARRANTY whatsoever; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# README file for additional terms and conditions on your use of this
# software.
#
# decompress archives based on mimetype
#
# TODO: confirm that all commands extract to a directory named after
#       the archive
# TODO: confirm that extraction never over-writes existing files
# TODO: Can we use trap to run the command after shell exit?

# Usage {{{1
usage() {
cat <<EOD
extract
© Copyright 2014-03-01 Ryan Delaney. All rights reserved.
Web site: http://github.com/rpdelaney

extract attempts to identify an archived file type and extract it to a
directory.

Usage: extract [OPTION]

Options
  -?, --help                  print this help and exit
  -v, --verbose               increase verbosity
  -n, --dry-run               don't extract: test compatibility
EOD
exit 1
}

# Arguments {{{1
#
while :
do
  case $1 in
    --help | -\?)
      #  Call your Help() or usage() function here.
      usage
      exit 1
      ;;
    -v | --verbose)
      # Each instance of -v adds 1 to verbosity
      verbose=$((verbose+1))
      shift
      ;;
    -n | --dry-run)
      dryrun="1"
      shift
      ;;
    --) # End of all options
      shift
      break
      ;;
    -*)
      echo "WARN: Unknown option (ignored): $1" >&2
      shift
      ;;
    *)  # no more options. Stop while loop
      break
      ;;
  esac
done

# Parameters {{{1
if [[ -n "$verbose" ]]; then
  set -x
fi

# Validate {{{1
  # that we are working with a file
if [[ ! -f "$1" ]] ; then
    echo "extract:: FATAL no such file $myfile"
    exit 1
else
  myfile="$1"
fi

  # get the filename
filename="$(basename $myfile)"  # Full filename
extension="${filename##*.}"     # Outer (last) extension only
shortname="${filename%.*}"      # Filename without the outer extension

  # get the mime type
    # this should use xdg-mime query filetype "$myfile" instead
mime=$(file -Lb --mime-type "$myfile")
echo "mimetype is: $mime"

  # Identify {{{1
case "$extension" in
  vpk)
    dep="vpk"
    cmd=(vpk "$myfile")
    ;;
esac

case "${mime#*-}" in
    text/PGP)
      dep="gpg"
      cmd=(gpg --output ${myfile/.gpg/} --decrypt $myfile)
      ;;
    tar)
      dep="tar"
      cmd=(tar kxfv "$myfile")
      ;;
    bzip2)
      dep="bunzip2"
      cmd=(bunzip2 "$myfile")
      ;;
    tar.bz2)
      dep="tar"
      cmd=(tar kxjfv "$myfile")
      ;;
    tar.gz)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    tbz2)
      dep="tar"
      cmd=(tar kxjfv "$myfile")
      ;;
    tgz)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    xz)
      dep="xz"
      cmd=(xz -dk "$myfile")
      ;;
    rar)
      dep="unrar"
      cmd=(unrar x "$myfile")
      ;;
    gzip)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    application/zip)
      dep="unzip"
      cmd=(unzip "$myfile")
      ;;
    Z)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    7z-compressed)
      dep="7za"
      cmd=(7za x "$myfile")
      ;;
    *)
      ;;
esac

if [[ -z "$dep" ]]; then
  echo "extract: unrecognized mimetype $mime"
  exit 1
fi

  # Check for missing dependency
[[ "$dep" ]] && type -P "$dep" > /dev/null || { echo "extract:: Missing dependency for MIME type $mime: $dep"; exit 1; }

# Extraction {{{1

if [[ -z "$dryrun" ]]; then
    # make a folder to extract into
  mkdir "$shortname"
  cd "$shortname"
  cp ../"$filename" .
    # Run the extraction command
  "${cmd[@]}"
    # Remove the old file
  rm "$filename"
  cd ..
else
  [[ -n "$verbose" ]] && echo "Extraction command was: ${cmd[@]}"
  exit 0
fi

# Cleanup {{{1

  # Warn me if I deleted the file somehow
[[ -e "$myfile" ]] || echo "extract:: WARNING! $1 was removed after extracting."

# Modelines {{{1
# vim: ft=sh foldmethod=marker
