#!/usr/bin/env bash
# GNU bash, version 4.2.45(2)-release (x86_64-unknown-linux-gnu)
#
# Â© Copyright 2014 Ryan Delaney. All rights reserved.  This work is
# distributed WITHOUT ANY WARRANTY whatsoever; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# README file for additional terms and conditions on your use of this
# software.
#
# decompress archives based on mimetype
#
# TODO: confirm that all commands extract to a directory named after
#       the archive
# TODO: confirm that extraction never over-writes existing files
# TODO: Can we use trap to run the command after shell exit?
# TODO: Leverage pv to display info about the output
# Functions {{{1
# verbose() {{{2
verbose() {
  # $1 is the message to be printed
  local message="$1"
  # $2 is the verbosity threshold (default: 1)
  local threshold="$2"

  if [[ "$verbose" -ge "$threshold" ]] && [[ -z "$quiet" ]]; then
    echo "$message" >&2 || return 1
  fi
}
# verbose() 2}}}
# error() {{{2
error() {
  #  is the message to be printed
  local message="$1"

  if [[ -z "$quiet" ]]; then
    echo "$message" >&2 || return 1
  fi
}
# error() 2}}}
# Functions 1}}}

# Usage {{{1
usage() {
cat <<EOD
extract

Usage: extract [OPTION] FILE

Options
  -?, --help                  print this help and exit
  -v, --verbose               increase verbosity
  -n, --dry-run               don't extract: test compatibility
EOD
exit 1
}

# Arguments {{{1
#
while :
do
  case $1 in
    --help | -\?)
      #  Call your Help() or usage() function here.
      usage
      exit 1
      ;;
    -v | --verbose)
      # Each instance of -v adds 1 to verbosity
      verbose=$((verbose+1))
      shift
      ;;
    -n | --dry-run)
      dryrun="1"
      shift
      ;;
    --) # End of all options
      shift
      break
      ;;
    -*)
      echo "WARN: Unknown option (ignored): $1" >&2
      shift
      ;;
    *)  # no more options. Stop while loop
      break
      ;;
  esac
done

# Validate {{{1
  # that we are working with a file
if [[ ! -f "$1" ]] ; then
    echo "extract:: FATAL no such file $myfile"
    exit 1
else
  myfile="$1"
fi

  # get the filename
filename="$(basename "$myfile")"  # Full filename
extension="${filename##*.}"     # Outer (last) extension only
shortname="${filename%.*}"      # Filename without the outer extension

  # get the mime type
    # this should use xdg-mime query filetype "$myfile" instead
mime=$(file -Lb --mime-type "$myfile")
echo "mimetype is: $mime"

  # Identify {{{1
case "$extension" in
  vpk)
    dep="vpk"
    cmd=(vpk "$myfile")
    ;;
esac

case "${mime#*-}" in
    text/PGP)
      dep="gpg"
      cmd=(gpg --output ${myfile/.gpg/} --decrypt "$myfile")
      ;;
    tar)
      dep="tar"
      cmd=(tar kxfv "$myfile")
      ;;
    bzip2)
      dep="bunzip2"
      cmd=(bunzip2 "$myfile")
      ;;
    tar.bz2)
      dep="tar"
      cmd=(tar kxjfv "$myfile")
      ;;
    tar.gz)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    tbz2)
      dep="tar"
      cmd=(tar kxjfv "$myfile")
      ;;
    tgz)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    xz)
      dep="xz"
      cmd=(xz -dk "$myfile")
      ;;
    rar)
      dep="unrar"
      cmd=(unrar x "$myfile")
      ;;
    gzip)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    application/zip)
      dep="unzip"
      cmd=(unzip "$myfile")
      ;;
    Z)
      dep="tar"
      cmd=(tar kxzfv "$myfile")
      ;;
    7z-compressed)
      dep="7za"
      cmd=(7za x "$myfile")
      ;;
    *)
      ;;
esac

if [[ -z "$dep" ]]; then
  echo "extract: unrecognized mimetype $mime"
  exit 1
fi

  # Check for missing dependency
if ! type "$dep" &> /dev/null; then echo "extract:: Missing dependency for MIME type $mime: $dep" 1>&2; exit 1; fi

# Extraction {{{1

if [[ -z "$dryrun" ]]; then
    # make a folder to extract into
  mkdir "$shortname" || exit 1
  cd "$shortname" || exit 1
  cp ../"$filename" . || exit 1
    # Run the extraction command
  "${cmd[@]}"
    # Remove the old file
  rm "$filename"
  cd ..
else
  [[ -n "$verbose" ]] && echo "Extraction command was: ${cmd[*]}"
  exit 0
fi

# Cleanup {{{1

  # Warn me if I deleted the file somehow
[[ -e "$myfile" ]] || echo "extract:: WARNING! $1 was removed after extracting."

# Modelines {{{1
# vim: ft=sh foldmethod=marker
