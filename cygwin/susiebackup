#!/usr/bin/env bash
  # set variables
pg_dump="/home/Ryan/pgsql/bin/pg_dump.exe"
dump_path="/cygdrive/c/Users/ryan/Documents/Dropbox/Sierra/Backup/"
hostip="192.168.68.27"
current_date="$(date +%Y-%m-%d__%H-%M-%S)"
backup_file="/tmp/$current_date.backup"
log_file="/tmp/$current_date.log"

# Are we in cygwin?
if echo "$(uname -o)" == "Cygwin"; then
    # Convert to cygwin paths
  pg_dump="$(cygpath -w $pg_dump)"
  dump_path="$(cygpath -w $dump_path)"
  backup_file="$(cygpath -w $backup_file)"
  log_file="$(cygpath -w $log_file)"
fi

  # check dependencies
[[ ! -d "$dump_path" ]] && { echo "Directory not found: $dump_path";  echo "$(realpath $0): FATAL. Files not found."; exit 1; }
[[ ! -f "$pg_dump" ]] && { echo "pg_dump not found: $pg_dump"; echo "$(realpath $0): FATAL. Files not found."; exit 1 ; }

#
# Do your business
#
echo "using backup file... $backup_file"
echo "using log file... $log_file"

echo "Executing pg_dump..."
pg_dump --host "$hostip" --port 5432 --username "postgres" --format tar --encoding UTF8 --verbose --file "$backup_file" susie &>> "$log_file"
pgdump_exit="$?"
echo "pg_dump process returned exit code: "$pgdump_exit | tee --append "$log_file"

#
# compress the backup
#
if type xz &> /dev/null; then
    if xz -v "$backup_file"; then backup_file="$backup_file".xz; else exit 1; fi
    if xz -v "$log_file"; then log_file="$log_file".xz; else exit 1; fi
else
    echo "$(realpath $0): FATAL. Archiver not found."
    exit 1
fi

#
# encrypt the backup
#
if type gpg &> /dev/null; then
  if gpg -v --output "$backup_file.gpg" --encrypt --recipient 0D98863B4E1D07B6 "$backup_file"; then
    backup_file="$backup_file.gpg"
    gpg -v --detach-sign "$backup_file"
  fi
  if gpg -v --output "$log_file.gpg"    --encrypt --recipient 0D98863B4E1D07B6 "$log_file"; then
    log_file="$log_file.gpg"
    gpg -v --detach-sign "$backup_file"
  fi
else
  echo "$(realpath $0): WARNING. The backup was not encrypted."
fi

  # show backup stats
stat "$backup_file"

#
# store the backup
#
if mv -v "$backup_file" "$dump_path" && mv -v "$log_file" "$dump_path"; then
  echo "Success."
else
  echo "FAILURE!"
fi

#
# restoring doesn't really work right now
#
              exit 0
#
#
#

  # then ask if we want to continue or not
if confirm "Do you want to attempt to restore?"; then
{
  set -x
    # drop the sandbox
  echo "Dropping sandbox database..."
  ssh -q -x mothership 'psql -U postgres -c "drop database susie;"'
  dropdb_exit=$?
  echo "dropdb process returned exit code: $dropdb_exit"

    # create the sandbox
  echo "Creating sandbox database..."
  ssh -q -x mothership 'psql -U postgres -c "create database susie;"'
  createdb_exit=$?
  echo "createdb process returned exit code: $createdb_exit"

    # restore to sandbox
  backup_basename="$(basename $backup_file)"
  echo "Uploading dump..."
  scp "$backup_file" ryan@mothership:/tmp/
  echo "Extracting dump..."
  ssh -q -x mothership 'bzip2 -d /tmp/'"$backup_basename"
  echo "Restoring to sandbox from dump..."
  ssh -q -x mothership "pg_restore -U postgres /tmp/${backup_basename%.bz2}"
  pgrestore_exit=$?
  echo "pg_restore process returned exit code: $pgrestore_exit"
}
fi
