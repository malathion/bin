#!/usr/bin/env bash
# vim: ft=sh foldmethod=marker
#
# Â© Copyright 2019 Ryan Delaney. All rights reserved.  This work is
# distributed WITHOUT ANY WARRANTY whatsoever; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# README file for additional terms and conditions on your use of this
# software.
#
# decompress archives based on mimetype
#
# TODO: confirm that all commands extract to a directory named after
#       the archive
# TODO: confirm that extraction never over-writes existing files
# TODO: Can we use trap to run the command after shell exit?
# TODO: Leverage pv to display info about the output

# Functions {{{1
# verbose() {{{2
verbose() {
  # $1 is the message to be printed
  local message="$1"
  # $2 is the verbosity threshold (default: 1)
  local threshold="$2"

  if [[ "$verbose" -ge "$threshold" ]] && [[ -z "$quiet" ]]; then
    echo "$message" >&2 || return 1
  fi
}
# verbose() 2}}}
# error() {{{2
error() {
  #  is the message to be printed
  local message="$1"

  if [[ -z "$quiet" ]]; then
    echo "$message" >&2 || return 1
  fi
}
# error() 2}}}
# Functions 1}}}

# Usage {{{1
usage() {
cat <<EOD
extract

Usage: extract [OPTION] FILE

Options
  -?, --help                  print this help and exit
  -v, --verbose               increase verbosity
  -n, --dry-run               don't extract: test compatibility
EOD
exit 1
}
# Usage 1}}}

# Arguments {{{1
#
while :
do
  case $1 in
    --help | -\?)
      #  Call your Help() or usage() function here.
      usage
      exit 1
      ;;
    -v | --verbose)
      # Each instance of -v adds 1 to verbosity
      verbose=$((verbose+1))
      shift
      ;;
    -n | --dry-run)
      dryrun="1"
      shift
      ;;
    --) # End of all options
      shift
      break
      ;;
    -*)
      error "WARN: Unknown option (ignored): $1" >&2
      shift
      ;;
    *)  # no more options. Stop while loop
      break
      ;;
  esac
done
# Arguments 1}}}

# Validate {{{1
  # that we are working with a file
if [[ ! -f "$1" ]] ; then
    error "extract:: FATAL no such file $myfile"
    exit 1
else
  myfile="$1"
fi

  # get the filename
filename="$(basename "$myfile")"  # Full filename
extension="${filename##*.}"     # Outer (last) extension only
shortname="${filename%.*}"      # Filename without the outer extension

  # get the mime type
#mime=$(file -Lb --mime-type "$myfile")
mime=$(xdg-mime query filetype "$myfile")
verbose "mimetype is: $mime"
# Validate 1}}}

  # Identify {{{1
case "$extension" in
  vpk)
    dep="vpk"
    ;;
esac

case "${mime#*-}" in
    text/PGP)
      dep="gpg"
      args="--output ${myfile/.gpg/} --decrypt"
      ;;
    tar)
      dep="tar"
      args="kxfv"
      ;;
    bzip2)
      dep="bunzip2"
      ;;
    tar.bz2)
      dep="tar"
      args="kxjfv"
      ;;
    tar.gz)
      dep="tar"
      args="kxzfv"
      ;;
    tbz2)
      dep="tar"
      args="kxjfv"
      ;;
    tgz)
      dep="tar"
      args="kxzfv"
      ;;
    xz)
      dep="xz"
      args="-dk"
      ;;
    rar)
      dep="unrar"
      args="x"
      ;;
    gzip)
      dep="tar"
      args="kxzfv"
      ;;
    application/zip)
      dep="unzip"
      ;;
    Z)
      dep="tar"
      args="kxzfv"
      ;;
    7z-compressed)
      dep="7za"
      args="x"
      ;;
    *)
      ;;
esac
# Identify 1}}}

command="$dep $args \"$myfile\""

if [[ -z "$dep" ]]; then
  error "extract: unrecognized mimetype $mime"
  exit 1
fi

  # Check for missing dependency
if ! type "$dep" &> /dev/null; then error "extract:: Missing dependency for MIME type $mime: $dep" 1>&2; exit 1; fi

# Extraction {{{1

if [[ -z "$dryrun" ]]; then
    # make a folder to extract into
  mkdir -p "$shortname" || exit
  cd "$shortname" || exit
  cp ../"$filename" . || exit
    # Run the extraction command
  eval "$command"
    # Remove the old file
  rm "$filename"
  cd ..
else
  verbose "Extraction command was: $command"
fi

# Cleanup {{{1

  # Warn me if I deleted the file somehow
[[ -e "$myfile" ]] || error "extract:: WARNING! $1 was removed after extracting."

# Modelines {{{1

# EOF
